<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building, Managing, and Running Containers with Docker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            background: #ffffff;
        }

        .slide {
            width: 100%;
            min-height: 100vh;
            padding: 60px 80px 80px 80px;
            page-break-after: always;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
        }
        
        .slide-footer {
            position: absolute;
            bottom: 20px;
            right: 80px;
            font-size: 0.9rem;
            color: #6b7280;
            font-style: italic;
            text-align: center;
        }

        .slide:last-child {
            page-break-after: auto;
        }

        .slide-header {
            text-align: center;
            margin-bottom: 50px;
        }

        .slide-title {
            font-size: 2.5rem;
            color: #1f2937;
            margin-bottom: 20px;
            font-weight: 700;
        }

        .slide-subtitle {
            font-size: 1.2rem;
            color: #6b7280;
            font-weight: 400;
        }

        .content {
            max-width: 900px;
            margin: 0 auto;
            width: 100%;
        }

        .title-slide {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            color: white;
            text-align: center;
        }

        .title-slide .slide-title {
            font-size: 3.5rem;
            color: white;
            margin-bottom: 30px;
        }

        .title-slide .slide-subtitle {
            font-size: 1.5rem;
            color: #93c5fd;
        }

        h2 {
            font-size: 2rem;
            color: #1f2937;
            margin-bottom: 30px;
            border-bottom: 3px solid #2563eb;
            padding-bottom: 10px;
        }

        h3 {
            font-size: 1.5rem;
            color: #374151;
            margin-bottom: 20px;
            margin-top: 30px;
        }

        p {
            font-size: 1.1rem;
            margin-bottom: 20px;
            text-align: justify;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        li {
            font-size: 1.1rem;
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .highlight-box {
            background: #eff6ff;
            border-left: 5px solid #2563eb;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .comparison-table th,
        .comparison-table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
        }

        .comparison-table th {
            background: #2563eb;
            color: white;
            font-weight: 600;
        }

        .comparison-table tr:hover {
            background: #eff6ff;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .feature-card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-top: 4px solid #2563eb;
        }

        .feature-card h4 {
            color: #1f2937;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .lab-section {
            background: #f0f9ff;
            border: 2px solid #0ea5e9;
            border-radius: 10px;
            padding: 30px;
            margin: 30px 0;
        }

        .lab-section h3 {
            color: #0369a1;
            margin-bottom: 20px;
        }

        .step-list {
            counter-reset: step-counter;
            list-style: none;
            margin-left: 0;
        }

        .step-list li {
            counter-increment: step-counter;
            position: relative;
            padding-left: 60px;
            margin-bottom: 20px;
        }

        .step-list li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: #0ea5e9;
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .code-block {
            background: #1f2937;
            color: #e5e7eb;
            padding: 20px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            overflow-x: auto;
            font-size: 0.95rem;
        }

        .docker-block {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            padding: 20px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            overflow-x: auto;
            font-size: 0.9rem;
        }

        .workflow-diagram {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .workflow-phase {
            background: #2563eb;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 5px;
            text-align: center;
            min-width: 120px;
            font-weight: bold;
        }

        .arrow {
            font-size: 1.5rem;
            color: #2563eb;
            margin: 0 10px;
        }

        .warning-box {
            background: #fef3c7;
            border-left: 5px solid #f59e0b;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .success-box {
            background: #d1fae5;
            border-left: 5px solid #10b981;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .architecture-diagram {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 30px 0;
            padding: 20px;
            background: #f9fafb;
            border-radius: 10px;
        }

        .arch-layer {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin: 10px 0;
        }

        .arch-component {
            background: #2563eb;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            text-align: center;
            min-width: 150px;
            font-weight: bold;
        }

        @media print {
            body {
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
            }
            
            .slide {
                page-break-inside: avoid;
                break-inside: avoid;
            }
        }
    </style>
</head>
<body>

<!-- Slide 1: Title Slide -->
<div class="slide title-slide">
    <div class="content">
        <h1 class="slide-title">Building, Managing, and Running Containers</h1>
        <p class="slide-subtitle">Comprehensive Guide to Docker and Containerization</p>
    </div>
    <div class="slide-footer" style="color: #93c5fd;">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 2: What are Containers? -->
<div class="slide">
    <div class="content">
        <h2>What are Containers?</h2>
        
        <div class="highlight-box">
            <p><strong>Containers</strong> are lightweight, portable, and self-sufficient units that package an application and all its dependencies, libraries, and configuration files needed to run the application consistently across different computing environments.</p>
        </div>

        <h3>Container Characteristics</h3>
        <ul>
            <li><strong>Lightweight:</strong> Share the host OS kernel, consuming fewer resources than virtual machines</li>
            <li><strong>Portable:</strong> Run consistently across development, testing, and production environments</li>
            <li><strong>Isolated:</strong> Applications run in separate namespaces with their own file systems</li>
            <li><strong>Scalable:</strong> Can be quickly started, stopped, and replicated</li>
            <li><strong>Immutable:</strong> Container images are read-only templates</li>
        </ul>

        <h3>Containers vs Virtual Machines</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Aspect</th>
                    <th>Containers</th>
                    <th>Virtual Machines</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Resource Usage</strong></td>
                    <td>Lightweight, share host OS</td>
                    <td>Heavy, full OS per VM</td>
                </tr>
                <tr>
                    <td><strong>Startup Time</strong></td>
                    <td>Seconds</td>
                    <td>Minutes</td>
                </tr>
                <tr>
                    <td><strong>Isolation</strong></td>
                    <td>Process-level isolation</td>
                    <td>Hardware-level isolation</td>
                </tr>
                <tr>
                    <td><strong>Portability</strong></td>
                    <td>Highly portable</td>
                    <td>Less portable</td>
                </tr>
                <tr>
                    <td><strong>Performance</strong></td>
                    <td>Near-native performance</td>
                    <td>Overhead from hypervisor</td>
                </tr>
            </tbody>
        </table>

        <h3>Container Use Cases</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Microservices</h4>
                <p>Package individual services with their dependencies for independent deployment and scaling.</p>
            </div>
            <div class="feature-card">
                <h4>CI/CD Pipelines</h4>
                <p>Consistent build and deployment environments across development lifecycle.</p>
            </div>
            <div class="feature-card">
                <h4>Application Modernization</h4>
                <p>Containerize legacy applications for cloud migration and modernization.</p>
            </div>
            <div class="feature-card">
                <h4>Development Environments</h4>
                <p>Standardized development environments that work across different machines.</p>
            </div>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 3: Why Docker in DevOps? -->
<div class="slide">
    <div class="content">
        <h2>Why Docker in DevOps?</h2>
        
        <h3>The DevOps Challenge</h3>
        <div class="highlight-box">
            <p>Traditional software development faces challenges with environment inconsistencies, complex deployments, and scaling difficulties. Docker addresses these challenges by providing a standardized way to package, distribute, and run applications.</p>
        </div>

        <h3>Docker's Role in DevOps</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Consistent Environments</h4>
                <p>Eliminates "works on my machine" problems by ensuring identical environments across development, testing, and production.</p>
            </div>
            <div class="feature-card">
                <h4>Faster Deployments</h4>
                <p>Containers start in seconds, enabling rapid deployment and rollback capabilities.</p>
            </div>
            <div class="feature-card">
                <h4>Resource Efficiency</h4>
                <p>Higher density deployments with better resource utilization compared to traditional VMs.</p>
            </div>
            <div class="feature-card">
                <h4>Simplified CI/CD</h4>
                <p>Streamlined build, test, and deployment pipelines with containerized applications.</p>
            </div>
        </div>

        <h3>DevOps Benefits with Docker</h3>
        <ul>
            <li><strong>Infrastructure as Code:</strong> Dockerfile defines infrastructure requirements</li>
            <li><strong>Version Control:</strong> Container images are versioned and stored in registries</li>
            <li><strong>Automated Testing:</strong> Consistent test environments across all stages</li>
            <li><strong>Scalability:</strong> Easy horizontal scaling with container orchestration</li>
            <li><strong>Rollback Capability:</strong> Quick rollback to previous container versions</li>
            <li><strong>Multi-Cloud Deployment:</strong> Portable across different cloud providers</li>
        </ul>

        <h3>Docker in the DevOps Toolchain</h3>
        <div class="workflow-diagram">
            <div class="workflow-phase">Code</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Build Image</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Test Container</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Deploy</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Monitor</div>
        </div>

        <h3>Real-World Impact</h3>
        <p>Organizations using Docker report 50% faster deployment times, 60% reduction in infrastructure costs, and 70% improvement in developer productivity through standardized containerized environments.</p>

        <div class="success-box">
            <p><strong>Key Insight:</strong> Docker transforms DevOps by making applications portable, scalable, and consistent across all environments, enabling true continuous delivery.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 4: Installing Docker -->
<div class="slide">
    <div class="content">
        <h2>Installing Docker</h2>
        
        <h3>System Requirements</h3>
        <div class="highlight-box">
            <p>Docker requires a 64-bit operating system and supports Linux, Windows, and macOS. For production environments, Linux is the preferred platform.</p>
        </div>

        <h3>Installation on Ubuntu (Recommended for Labs)</h3>
        <div class="code-block">
# Update package index<br>
sudo apt update<br><br>

# Install prerequisite packages<br>
sudo apt install apt-transport-https ca-certificates curl software-properties-common<br><br>

# Add Docker's official GPG key<br>
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br><br>

# Add Docker repository<br>
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null<br><br>

# Update package index again<br>
sudo apt update<br><br>

# Install Docker CE<br>
sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        </div>

        <h3>Post-Installation Steps</h3>
        <div class="code-block">
# Start and enable Docker service<br>
sudo systemctl start docker<br>
sudo systemctl enable docker<br><br>

# Add user to docker group (avoid using sudo)<br>
sudo usermod -aG docker $USER<br><br>

# Log out and log back in, or run:<br>
newgrp docker<br><br>

# Verify installation<br>
docker --version<br>
docker run hello-world
        </div>

        <h3>Installation on Other Platforms</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Platform</th>
                    <th>Installation Method</th>
                    <th>Notes</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Windows</strong></td>
                    <td>Docker Desktop for Windows</td>
                    <td>Requires WSL2 or Hyper-V</td>
                </tr>
                <tr>
                    <td><strong>macOS</strong></td>
                    <td>Docker Desktop for Mac</td>
                    <td>Intel and Apple Silicon support</td>
                </tr>
                <tr>
                    <td><strong>CentOS/RHEL</strong></td>
                    <td>yum/dnf package manager</td>
                    <td>Similar to Ubuntu process</td>
                </tr>
                <tr>
                    <td><strong>Amazon Linux</strong></td>
                    <td>yum install docker</td>
                    <td>Pre-installed on many AMIs</td>
                </tr>
            </tbody>
        </table>

        <h3>Verification Commands</h3>
        <div class="docker-block">
# Check Docker version<br>
docker --version<br><br>

# Display system information<br>
docker info<br><br>

# Test Docker installation<br>
docker run hello-world<br><br>

# Check running containers<br>
docker ps<br><br>

# Check all containers<br>
docker ps -a
        </div>

        <div class="warning-box">
            <p><strong>Security Note:</strong> Adding users to the docker group grants root-level privileges. In production, consider using rootless Docker or proper access controls.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 5: Docker Architecture Overview -->
<div class="slide">
    <div class="content">
        <h2>Docker Architecture: Overview</h2>
        
        <h3>Docker Architecture Components</h3>
        <div class="highlight-box">
            <p>Docker uses a client-server architecture with three main components: <strong>Docker Client</strong>, <strong>Docker Daemon</strong>, and <strong>Docker Registry</strong>. These components work together to build, run, and distribute containers.</p>
        </div>

        <h3>Architecture Diagram</h3>
        <div class="architecture-diagram">
            <div class="arch-layer">
                <div class="arch-component">Docker Client (CLI)</div>
                <div class="arch-component">Docker Desktop</div>
                <div class="arch-component">Docker API</div>
            </div>
            <div style="text-align: center; margin: 10px 0; font-size: 1.5rem; color: #2563eb;">↕</div>
            <div class="arch-layer">
                <div class="arch-component">Docker Daemon (dockerd)</div>
            </div>
            <div style="text-align: center; margin: 10px 0; font-size: 1.5rem; color: #2563eb;">↕</div>
            <div class="arch-layer">
                <div class="arch-component">Images</div>
                <div class="arch-component">Containers</div>
                <div class="arch-component">Networks</div>
                <div class="arch-component">Volumes</div>
            </div>
            <div style="text-align: center; margin: 10px 0; font-size: 1.5rem; color: #2563eb;">↕</div>
            <div class="arch-layer">
                <div class="arch-component">Docker Registry (Docker Hub)</div>
            </div>
        </div>

        <h3>Component Descriptions</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Docker Client</h4>
                <p>Command-line interface that users interact with. Sends commands to Docker daemon via REST API.</p>
            </div>
            <div class="feature-card">
                <h4>Docker Daemon</h4>
                <p>Background service that manages Docker objects like images, containers, networks, and volumes.</p>
            </div>
            <div class="feature-card">
                <h4>Docker Images</h4>
                <p>Read-only templates used to create containers. Built from Dockerfile instructions.</p>
            </div>
            <div class="feature-card">
                <h4>Docker Registry</h4>
                <p>Storage and distribution system for Docker images. Docker Hub is the default public registry.</p>
            </div>
        </div>

        <h3>How Components Interact</h3>
        <ol>
            <li><strong>Client Command:</strong> User runs <code>docker run nginx</code></li>
            <li><strong>API Call:</strong> Client sends REST API request to daemon</li>
            <li><strong>Image Check:</strong> Daemon checks if nginx image exists locally</li>
            <li><strong>Image Pull:</strong> If not found, daemon pulls from registry</li>
            <li><strong>Container Creation:</strong> Daemon creates and starts container from image</li>
            <li><strong>Response:</strong> Client receives confirmation and container ID</li>
        </ol>

        <div class="success-box">
            <p><strong>Key Concept:</strong> Docker's architecture separates the user interface (client) from the execution engine (daemon), enabling remote Docker management and API-based automation.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 6: Docker Engine -->
<div class="slide">
    <div class="content">
        <h2>Docker Engine</h2>
        
        <h3>What is Docker Engine?</h3>
        <div class="highlight-box">
            <p><strong>Docker Engine</strong> is the core runtime that creates and manages containers. It consists of the Docker daemon (dockerd), REST API, and command-line interface (CLI).</p>
        </div>

        <h3>Docker Engine Components</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Docker Daemon (dockerd)</h4>
                <p>Background process that manages Docker objects and handles API requests from Docker clients.</p>
            </div>
            <div class="feature-card">
                <h4>REST API</h4>
                <p>Interface that programs can use to talk to and instruct the Docker daemon.</p>
            </div>
            <div class="feature-card">
                <h4>Docker CLI</h4>
                <p>Command-line interface client that uses the REST API to control the Docker daemon.</p>
            </div>
            <div class="feature-card">
                <h4>containerd</h4>
                <p>High-level container runtime that manages container lifecycle and image management.</p>
            </div>
        </div>

        <h3>Engine Architecture Layers</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Layer</th>
                    <th>Component</th>
                    <th>Responsibility</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>User Interface</strong></td>
                    <td>Docker CLI, Docker Desktop</td>
                    <td>User interaction and commands</td>
                </tr>
                <tr>
                    <td><strong>API Layer</strong></td>
                    <td>Docker REST API</td>
                    <td>Communication protocol</td>
                </tr>
                <tr>
                    <td><strong>Engine Layer</strong></td>
                    <td>Docker Daemon (dockerd)</td>
                    <td>Container management and orchestration</td>
                </tr>
                <tr>
                    <td><strong>Runtime Layer</strong></td>
                    <td>containerd, runc</td>
                    <td>Container execution and lifecycle</td>
                </tr>
                <tr>
                    <td><strong>OS Layer</strong></td>
                    <td>Linux Kernel</td>
                    <td>Namespaces, cgroups, filesystem</td>
                </tr>
            </tbody>
        </table>

        <h3>Docker Engine Operations</h3>
        <div class="code-block">
# Check Docker Engine status<br>
sudo systemctl status docker<br><br>

# Start Docker Engine<br>
sudo systemctl start docker<br><br>

# Stop Docker Engine<br>
sudo systemctl stop docker<br><br>

# Restart Docker Engine<br>
sudo systemctl restart docker<br><br>

# View Docker Engine logs<br>
sudo journalctl -u docker.service<br><br>

# Configure Docker Engine<br>
sudo nano /etc/docker/daemon.json
        </div>

        <h3>Engine Configuration</h3>
        <div class="docker-block">
# /etc/docker/daemon.json<br>
{<br>
&nbsp;&nbsp;"log-driver": "json-file",<br>
&nbsp;&nbsp;"log-opts": {<br>
&nbsp;&nbsp;&nbsp;&nbsp;"max-size": "10m",<br>
&nbsp;&nbsp;&nbsp;&nbsp;"max-file": "3"<br>
&nbsp;&nbsp;},<br>
&nbsp;&nbsp;"storage-driver": "overlay2",<br>
&nbsp;&nbsp;"insecure-registries": ["myregistry.com:5000"],<br>
&nbsp;&nbsp;"registry-mirrors": ["https://mirror.gcr.io"]<br>
}
        </div>

        <div class="warning-box">
            <p><strong>Important:</strong> Always restart the Docker daemon after modifying the configuration file for changes to take effect.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 7: Docker Images -->
<div class="slide">
    <div class="content">
        <h2>Docker Images</h2>
        
        <h3>Understanding Docker Images</h3>
        <div class="highlight-box">
            <p><strong>Docker Images</strong> are read-only templates that contain a set of instructions for creating containers. They include the application code, runtime, system tools, libraries, and settings needed to run an application.</p>
        </div>

        <h3>Image Characteristics</h3>
        <ul>
            <li><strong>Layered Architecture:</strong> Images are built in layers, each representing a set of file changes</li>
            <li><strong>Immutable:</strong> Once created, image layers cannot be modified</li>
            <li><strong>Shareable:</strong> Layers can be shared between different images</li>
            <li><strong>Versioned:</strong> Images can be tagged with different versions</li>
            <li><strong>Portable:</strong> Can run on any system with Docker installed</li>
        </ul>

        <h3>Image Layers</h3>
        <div class="architecture-diagram">
            <div class="arch-layer">
                <div class="arch-component">Application Layer</div>
            </div>
            <div class="arch-layer">
                <div class="arch-component">Dependencies Layer</div>
            </div>
            <div class="arch-layer">
                <div class="arch-component">Runtime Layer</div>
            </div>
            <div class="arch-layer">
                <div class="arch-component">OS Libraries Layer</div>
            </div>
            <div class="arch-layer">
                <div class="arch-component">Base OS Layer</div>
            </div>
        </div>

        <h3>Image Naming Convention</h3>
        <div class="docker-block">
# Full image name format:<br>
[registry-host[:port]/][username/]repository[:tag]<br><br>

# Examples:<br>
nginx                           # Official nginx image, latest tag<br>
nginx:1.21                      # nginx version 1.21<br>
ubuntu:20.04                    # Ubuntu 20.04 LTS<br>
docker.io/library/nginx:latest  # Full name for nginx<br>
myregistry.com:5000/myapp:v1.0  # Private registry image<br>
username/myapp:dev              # User's repository
        </div>

        <h3>Image Storage</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Local Storage</h4>
                <p>Images stored locally in /var/lib/docker/ directory with efficient layer sharing.</p>
            </div>
            <div class="feature-card">
                <h4>Registry Storage</h4>
                <p>Images stored in registries like Docker Hub, AWS ECR, or private registries.</p>
            </div>
            <div class="feature-card">
                <h4>Layer Caching</h4>
                <p>Docker caches layers to speed up builds and reduce storage usage.</p>
            </div>
            <div class="feature-card">
                <h4>Content Addressing</h4>
                <p>Images identified by cryptographic hashes ensuring integrity.</p>
            </div>
        </div>

        <h3>Image Lifecycle</h3>
        <div class="workflow-diagram">
            <div class="workflow-phase">Build</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Tag</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Push</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Pull</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Run</div>
        </div>

        <h3>Base Images</h3>
        <p>Most Docker images are built on top of base images that provide the foundation operating system and basic tools. Popular base images include:</p>
        <ul>
            <li><strong>Alpine Linux:</strong> Minimal, security-focused (5MB)</li>
            <li><strong>Ubuntu:</strong> Full-featured, widely used (72MB)</li>
            <li><strong>Debian:</strong> Stable, well-maintained (124MB)</li>
            <li><strong>CentOS:</strong> Enterprise-focused (200MB)</li>
            <li><strong>Scratch:</strong> Empty image for static binaries</li>
        </ul>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 8: Docker Containers -->
<div class="slide">
    <div class="content">
        <h2>Docker Containers</h2>
        
        <h3>Understanding Containers</h3>
        <div class="highlight-box">
            <p><strong>Docker Containers</strong> are running instances of Docker images. They are isolated, lightweight, and include everything needed to run an application: code, runtime, system tools, libraries, and settings.</p>
        </div>

        <h3>Container vs Image Relationship</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Docker Image</h4>
                <p>• Read-only template<br>• Static blueprint<br>• Stored in registry<br>• Immutable layers</p>
            </div>
            <div class="feature-card">
                <h4>Docker Container</h4>
                <p>• Running instance<br>• Dynamic process<br>• Has writable layer<br>• Can be started/stopped</p>
            </div>
        </div>

        <h3>Container Lifecycle States</h3>
        <div class="workflow-diagram">
            <div class="workflow-phase">Created</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Running</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Paused</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Stopped</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Deleted</div>
        </div>

        <h3>Container Isolation</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Isolation Type</th>
                    <th>Technology</th>
                    <th>Purpose</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Process Isolation</strong></td>
                    <td>PID Namespaces</td>
                    <td>Separate process trees</td>
                </tr>
                <tr>
                    <td><strong>Network Isolation</strong></td>
                    <td>Network Namespaces</td>
                    <td>Separate network stacks</td>
                </tr>
                <tr>
                    <td><strong>Filesystem Isolation</strong></td>
                    <td>Mount Namespaces</td>
                    <td>Separate filesystem views</td>
                </tr>
                <tr>
                    <td><strong>User Isolation</strong></td>
                    <td>User Namespaces</td>
                    <td>Separate user/group IDs</td>
                </tr>
                <tr>
                    <td><strong>Resource Limits</strong></td>
                    <td>Control Groups (cgroups)</td>
                    <td>CPU, memory, I/O limits</td>
                </tr>
            </tbody>
        </table>

        <h3>Container Runtime</h3>
        <p>Containers run as processes on the host system but with isolation provided by Linux kernel features:</p>
        <ul>
            <li><strong>Namespaces:</strong> Provide isolation for system resources</li>
            <li><strong>Control Groups (cgroups):</strong> Limit and monitor resource usage</li>
            <li><strong>Union Filesystems:</strong> Layer multiple filesystems together</li>
            <li><strong>Security:</strong> AppArmor, SELinux, seccomp profiles</li>
        </ul>

        <h3>Container Advantages</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Fast Startup</h4>
                <p>Containers start in seconds, not minutes like VMs</p>
            </div>
            <div class="feature-card">
                <h4>Resource Efficient</h4>
                <p>Share host OS kernel, minimal overhead</p>
            </div>
            <div class="feature-card">
                <h4>Consistent Environment</h4>
                <p>Same runtime environment everywhere</p>
            </div>
            <div class="feature-card">
                <h4>Easy Scaling</h4>
                <p>Quickly create multiple instances</p>
            </div>
        </div>

        <h3>Container Networking</h3>
        <p>Containers can communicate through various networking modes:</p>
        <ul>
            <li><strong>Bridge Network:</strong> Default isolated network</li>
            <li><strong>Host Network:</strong> Share host's network stack</li>
            <li><strong>None Network:</strong> No network access</li>
            <li><strong>Custom Networks:</strong> User-defined networks</li>
        </ul>

        <div class="success-box">
            <p><strong>Key Insight:</strong> Containers provide process-level isolation while sharing the host OS kernel, making them much more efficient than traditional virtual machines.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 9: Basic Docker Commands Overview -->
<div class="slide">
    <div class="content">
        <h2>Basic Docker Commands</h2>
        
        <h3>Essential Docker Commands</h3>
        <div class="highlight-box">
            <p>Docker provides a comprehensive set of commands to manage containers, images, networks, and volumes. Understanding these basic commands is essential for working with Docker effectively.</p>
        </div>

        <h3>Command Categories</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Container Management</h4>
                <p><code>docker run</code>, <code>docker ps</code>, <code>docker stop</code>, <code>docker start</code>, <code>docker rm</code></p>
            </div>
            <div class="feature-card">
                <h4>Image Management</h4>
                <p><code>docker images</code>, <code>docker pull</code>, <code>docker push</code>, <code>docker build</code>, <code>docker rmi</code></p>
            </div>
            <div class="feature-card">
                <h4>Container Interaction</h4>
                <p><code>docker exec</code>, <code>docker logs</code>, <code>docker cp</code>, <code>docker attach</code></p>
            </div>
            <div class="feature-card">
                <h4>System Management</h4>
                <p><code>docker info</code>, <code>docker version</code>, <code>docker system</code>, <code>docker stats</code></p>
            </div>
        </div>

        <h3>Command Structure</h3>
        <div class="docker-block">
# Basic Docker command structure<br>
docker [OPTIONS] COMMAND [ARG...]<br><br>

# Examples:<br>
docker --version                    # Show Docker version<br>
docker info                         # Display system information<br>
docker help                         # Show help information<br>
docker COMMAND --help               # Show help for specific command
        </div>

        <h3>Common Options</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Option</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>-d, --detach</code></td>
                    <td>Run container in background</td>
                    <td><code>docker run -d nginx</code></td>
                </tr>
                <tr>
                    <td><code>-it</code></td>
                    <td>Interactive terminal</td>
                    <td><code>docker run -it ubuntu bash</code></td>
                </tr>
                <tr>
                    <td><code>-p, --publish</code></td>
                    <td>Publish container port</td>
                    <td><code>docker run -p 80:80 nginx</code></td>
                </tr>
                <tr>
                    <td><code>-v, --volume</code></td>
                    <td>Mount volume</td>
                    <td><code>docker run -v /data:/app/data nginx</code></td>
                </tr>
                <tr>
                    <td><code>--name</code></td>
                    <td>Assign container name</td>
                    <td><code>docker run --name web nginx</code></td>
                </tr>
            </tbody>
        </table>

        <h3>Getting Help</h3>
        <div class="code-block">
# General help<br>
docker --help<br><br>

# Command-specific help<br>
docker run --help<br>
docker build --help<br>
docker ps --help<br><br>

# List all commands<br>
docker command ls<br><br>

# Docker documentation<br>
# Visit: https://docs.docker.com/
        </div>

        <div class="success-box">
            <p><strong>Pro Tip:</strong> Use <code>docker COMMAND --help</code> to quickly access documentation for any Docker command without leaving the terminal.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 10: docker run Command -->
<div class="slide">
    <div class="content">
        <h2>docker run Command</h2>
        
        <h3>Understanding docker run</h3>
        <div class="highlight-box">
            <p><strong>docker run</strong> creates and starts a new container from a Docker image. It's the most commonly used Docker command and combines image pulling, container creation, and container starting into one command.</p>
        </div>

        <h3>Basic Syntax</h3>
        <div class="docker-block">
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br><br>

# Simple examples:<br>
docker run hello-world              # Run hello-world container<br>
docker run ubuntu                   # Run Ubuntu container<br>
docker run nginx                    # Run Nginx web server<br>
docker run -d nginx                 # Run Nginx in background
        </div>

        <h3>Common docker run Options</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Option</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>-d, --detach</code></td>
                    <td>Run in background (daemon mode)</td>
                    <td><code>docker run -d nginx</code></td>
                </tr>
                <tr>
                    <td><code>-it</code></td>
                    <td>Interactive mode with TTY</td>
                    <td><code>docker run -it ubuntu bash</code></td>
                </tr>
                <tr>
                    <td><code>-p, --publish</code></td>
                    <td>Port mapping host:container</td>
                    <td><code>docker run -p 8080:80 nginx</code></td>
                </tr>
                <tr>
                    <td><code>--name</code></td>
                    <td>Assign container name</td>
                    <td><code>docker run --name web nginx</code></td>
                </tr>
                <tr>
                    <td><code>-v, --volume</code></td>
                    <td>Mount volume or bind mount</td>
                    <td><code>docker run -v /data:/var/data nginx</code></td>
                </tr>
                <tr>
                    <td><code>-e, --env</code></td>
                    <td>Set environment variables</td>
                    <td><code>docker run -e NODE_ENV=production node</code></td>
                </tr>
                <tr>
                    <td><code>--rm</code></td>
                    <td>Remove container when it exits</td>
                    <td><code>docker run --rm ubuntu echo "hello"</code></td>
                </tr>
            </tbody>
        </table>

        <h3>Practical Examples</h3>
        <div class="code-block">
# Run Nginx web server on port 8080<br>
docker run -d -p 8080:80 --name my-nginx nginx<br><br>

# Run interactive Ubuntu container<br>
docker run -it --name my-ubuntu ubuntu:20.04 /bin/bash<br><br>

# Run container with environment variables<br>
docker run -d -e MYSQL_ROOT_PASSWORD=secret mysql:8.0<br><br>

# Run container with volume mount<br>
docker run -d -p 80:80 -v /host/data:/usr/share/nginx/html nginx<br><br>

# Run temporary container (auto-remove)<br>
docker run --rm -it python:3.9 python<br><br>

# Run container with custom command<br>
docker run ubuntu echo "Hello from Ubuntu container"
        </div>

        <h3>Port Mapping Examples</h3>
        <div class="docker-block">
# Map single port<br>
docker run -p 8080:80 nginx                    # Host:8080 -> Container:80<br><br>

# Map multiple ports<br>
docker run -p 8080:80 -p 8443:443 nginx       # Multiple port mappings<br><br>

# Map to specific interface<br>
docker run -p 127.0.0.1:8080:80 nginx         # Bind to localhost only<br><br>

# Map random host port<br>
docker run -P nginx                            # Docker assigns random ports<br><br>

# UDP port mapping<br>
docker run -p 53:53/udp dns-server             # Map UDP port
        </div>

        <h3>What Happens When You Run docker run</h3>
        <ol class="step-list">
            <li><strong>Image Check:</strong> Docker checks if the image exists locally</li>
            <li><strong>Image Pull:</strong> If not found locally, pulls from registry</li>
            <li><strong>Container Creation:</strong> Creates a new container from the image</li>
            <li><strong>Network Setup:</strong> Configures networking for the container</li>
            <li><strong>Container Start:</strong> Starts the container and runs the specified command</li>
        </ol>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 11: docker ps Command -->
<div class="slide">
    <div class="content">
        <h2>docker ps Command</h2>
        
        <h3>Listing Containers</h3>
        <div class="highlight-box">
            <p><strong>docker ps</strong> lists containers on your system. By default, it shows only running containers, but with options, you can view all containers, filter results, and customize the output format.</p>
        </div>

        <h3>Basic Usage</h3>
        <div class="code-block">
# List running containers<br>
docker ps<br><br>

# List all containers (running and stopped)<br>
docker ps -a<br><br>

# List only container IDs<br>
docker ps -q<br><br>

# List all container IDs<br>
docker ps -aq
        </div>

        <h3>docker ps Options</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Option</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>-a, --all</code></td>
                    <td>Show all containers (running and stopped)</td>
                    <td><code>docker ps -a</code></td>
                </tr>
                <tr>
                    <td><code>-q, --quiet</code></td>
                    <td>Only show container IDs</td>
                    <td><code>docker ps -q</code></td>
                </tr>
                <tr>
                    <td><code>-l, --latest</code></td>
                    <td>Show the latest created container</td>
                    <td><code>docker ps -l</code></td>
                </tr>
                <tr>
                    <td><code>-n</code></td>
                    <td>Show last n created containers</td>
                    <td><code>docker ps -n 5</code></td>
                </tr>
                <tr>
                    <td><code>-s, --size</code></td>
                    <td>Display total file sizes</td>
                    <td><code>docker ps -s</code></td>
                </tr>
                <tr>
                    <td><code>--format</code></td>
                    <td>Pretty-print using Go template</td>
                    <td><code>docker ps --format "table {{.Names}}\t{{.Status}}"</code></td>
                </tr>
            </tbody>
        </table>

        <h3>Understanding docker ps Output</h3>
        <div class="docker-block">
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                NAMES<br>
a1b2c3d4e5f6   nginx     "/docker-entrypoint.…"   2 minutes ago   Up 2 minutes   0.0.0.0:8080->80/tcp   my-nginx<br>
b2c3d4e5f6g7   ubuntu    "/bin/bash"              5 minutes ago   Exited (0)     -                    my-ubuntu
        </div>

        <h3>Column Explanations</h3>
        <ul>
            <li><strong>CONTAINER ID:</strong> Unique identifier for the container (short form)</li>
            <li><strong>IMAGE:</strong> Docker image used to create the container</li>
            <li><strong>COMMAND:</strong> Command that was run when container started</li>
            <li><strong>CREATED:</strong> When the container was created</li>
            <li><strong>STATUS:</strong> Current status (Up, Exited, Restarting, etc.)</li>
            <li><strong>PORTS:</strong> Port mappings between host and container</li>
            <li><strong>NAMES:</strong> Container name (auto-generated or user-assigned)</li>
        </ul>

        <h3>Filtering Containers</h3>
        <div class="code-block">
# Filter by status<br>
docker ps --filter "status=running"<br>
docker ps --filter "status=exited"<br><br>

# Filter by name<br>
docker ps --filter "name=nginx"<br><br>

# Filter by image<br>
docker ps --filter "ancestor=ubuntu"<br><br>

# Filter by label<br>
docker ps --filter "label=environment=production"<br><br>

# Multiple filters<br>
docker ps --filter "status=running" --filter "name=web"
        </div>

        <h3>Custom Output Formatting</h3>
        <div class="code-block">
# Custom table format<br>
docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}"<br><br>

# JSON format<br>
docker ps --format "{{json .}}"<br><br>

# Simple format<br>
docker ps --format "{{.Names}}: {{.Status}}"<br><br>

# Show only names and ports<br>
docker ps --format "table {{.Names}}\t{{.Ports}}"
        </div>

        <h3>Practical Examples</h3>
        <div class="code-block">
# Count running containers<br>
docker ps -q | wc -l<br><br>

# Get container IDs for cleanup<br>
docker ps -aq --filter "status=exited"<br><br>

# Monitor container status<br>
watch docker ps<br><br>

# Show containers with their sizes<br>
docker ps -as
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 12: docker stop and docker rm Commands -->
<div class="slide">
    <div class="content">
        <h2>docker stop and docker rm Commands</h2>
        
        <h3>Stopping Containers</h3>
        <div class="highlight-box">
            <p><strong>docker stop</strong> gracefully stops running containers by sending a SIGTERM signal, followed by SIGKILL if the container doesn't stop within the timeout period (default 10 seconds).</p>
        </div>

        <h3>docker stop Command</h3>
        <div class="code-block">
# Stop a container by name<br>
docker stop my-nginx<br><br>

# Stop a container by ID<br>
docker stop a1b2c3d4e5f6<br><br>

# Stop multiple containers<br>
docker stop container1 container2 container3<br><br>

# Stop all running containers<br>
docker stop $(docker ps -q)<br><br>

# Stop with custom timeout (in seconds)<br>
docker stop -t 30 my-nginx
        </div>

        <h3>docker kill vs docker stop</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Command</th>
                    <th>Signal</th>
                    <th>Behavior</th>
                    <th>Use Case</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>docker stop</code></td>
                    <td>SIGTERM then SIGKILL</td>
                    <td>Graceful shutdown</td>
                    <td>Normal container shutdown</td>
                </tr>
                <tr>
                    <td><code>docker kill</code></td>
                    <td>SIGKILL (default)</td>
                    <td>Immediate termination</td>
                    <td>Force stop unresponsive containers</td>
                </tr>
            </tbody>
        </table>

        <h3>Removing Containers</h3>
        <div class="highlight-box">
            <p><strong>docker rm</strong> removes one or more containers. Containers must be stopped before they can be removed, unless you use the force option.</p>
        </div>

        <h3>docker rm Command</h3>
        <div class="code-block">
# Remove a stopped container<br>
docker rm my-nginx<br><br>

# Remove multiple containers<br>
docker rm container1 container2<br><br>

# Force remove a running container<br>
docker rm -f my-nginx<br><br>

# Remove all stopped containers<br>
docker rm $(docker ps -aq --filter "status=exited")<br><br>

# Remove container and its volumes<br>
docker rm -v my-container
        </div>

        <h3>docker rm Options</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Option</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>-f, --force</code></td>
                    <td>Force remove running container</td>
                    <td><code>docker rm -f my-container</code></td>
                </tr>
                <tr>
                    <td><code>-v, --volumes</code></td>
                    <td>Remove associated volumes</td>
                    <td><code>docker rm -v my-container</code></td>
                </tr>
                <tr>
                    <td><code>-l, --link</code></td>
                    <td>Remove specified link</td>
                    <td><code>docker rm -l my-link</code></td>
                </tr>
            </tbody>
        </table>

        <h3>Container Lifecycle Management</h3>
        <div class="workflow-diagram">
            <div class="workflow-phase">docker run</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Running</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">docker stop</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">Stopped</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">docker rm</div>
        </div>

        <h3>Cleanup Commands</h3>
        <div class="code-block">
# Stop and remove all containers<br>
docker stop $(docker ps -aq) && docker rm $(docker ps -aq)<br><br>

# Remove all stopped containers<br>
docker container prune<br><br>

# Remove all containers (force)<br>
docker rm -f $(docker ps -aq)<br><br>

# Clean up everything (containers, networks, images)<br>
docker system prune<br><br>

# Clean up with volumes<br>
docker system prune --volumes
        </div>

        <h3>Best Practices</h3>
        <ul>
            <li><strong>Graceful Shutdown:</strong> Use <code>docker stop</code> instead of <code>docker kill</code> when possible</li>
            <li><strong>Auto-removal:</strong> Use <code>--rm</code> flag with <code>docker run</code> for temporary containers</li>
            <li><strong>Regular Cleanup:</strong> Periodically remove stopped containers to free up space</li>
            <li><strong>Container Names:</strong> Use meaningful names for easier management</li>
        </ul>

        <div class="warning-box">
            <p><strong>Warning:</strong> <code>docker rm -f</code> forcefully terminates containers without graceful shutdown. Use with caution in production environments.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 13: docker exec Command -->
<div class="slide">
    <div class="content">
        <h2>docker exec Command</h2>
        
        <h3>Executing Commands in Running Containers</h3>
        <div class="highlight-box">
            <p><strong>docker exec</strong> runs commands inside running containers. This is essential for debugging, maintenance, and interactive work with containerized applications.</p>
        </div>

        <h3>Basic Syntax</h3>
        <div class="docker-block">
docker exec [OPTIONS] CONTAINER COMMAND [ARG...]<br><br>

# Basic examples:<br>
docker exec my-container ls /app<br>
docker exec my-container cat /etc/hostname<br>
docker exec my-container ps aux
        </div>

        <h3>Interactive Mode</h3>
        <div class="code-block">
# Start interactive bash session<br>
docker exec -it my-container bash<br><br>

# Start interactive shell (sh for Alpine)<br>
docker exec -it my-container sh<br><br>

# Run interactive Python<br>
docker exec -it my-python-app python<br><br>

# Access MySQL command line<br>
docker exec -it my-mysql mysql -u root -p
        </div>

        <h3>docker exec Options</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Option</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>-i, --interactive</code></td>
                    <td>Keep STDIN open</td>
                    <td><code>docker exec -i container cat > file.txt</code></td>
                </tr>
                <tr>
                    <td><code>-t, --tty</code></td>
                    <td>Allocate pseudo-TTY</td>
                    <td><code>docker exec -t container ls</code></td>
                </tr>
                <tr>
                    <td><code>-d, --detach</code></td>
                    <td>Run in background</td>
                    <td><code>docker exec -d container service nginx start</code></td>
                </tr>
                <tr>
                    <td><code>-u, --user</code></td>
                    <td>Run as specific user</td>
                    <td><code>docker exec -u root container bash</code></td>
                </tr>
                <tr>
                    <td><code>-w, --workdir</code></td>
                    <td>Set working directory</td>
                    <td><code>docker exec -w /app container ls</code></td>
                </tr>
                <tr>
                    <td><code>-e, --env</code></td>
                    <td>Set environment variables</td>
                    <td><code>docker exec -e VAR=value container env</code></td>
                </tr>
            </tbody>
        </table>

        <h3>Common Use Cases</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Debugging</h4>
                <p>Access container filesystem, check logs, inspect processes</p>
            </div>
            <div class="feature-card">
                <h4>Maintenance</h4>
                <p>Update configurations, restart services, clean up files</p>
            </div>
            <div class="feature-card">
                <h4>Database Access</h4>
                <p>Connect to database CLI, run queries, backup data</p>
            </div>
            <div class="feature-card">
                <h4>File Operations</h4>
                <p>Edit files, check permissions, transfer data</p>
            </div>
        </div>

        <h3>Practical Examples</h3>
        <div class="code-block">
# Check container processes<br>
docker exec my-container ps aux<br><br>

# View container logs<br>
docker exec my-container tail -f /var/log/app.log<br><br>

# Check disk usage<br>
docker exec my-container df -h<br><br>

# Install package (temporary)<br>
docker exec -it my-container apt update && apt install -y vim<br><br>

# Check network configuration<br>
docker exec my-container ip addr show<br><br>

# Run as different user<br>
docker exec -u www-data my-web-container whoami
        </div>

        <h3>Database Examples</h3>
        <div class="code-block">
# MySQL database access<br>
docker exec -it mysql-container mysql -u root -p<br><br>

# PostgreSQL database access<br>
docker exec -it postgres-container psql -U postgres<br><br>

# MongoDB access<br>
docker exec -it mongo-container mongo<br><br>

# Redis CLI<br>
docker exec -it redis-container redis-cli
        </div>

        <h3>File Operations</h3>
        <div class="code-block">
# Edit configuration file<br>
docker exec -it my-container vi /etc/nginx/nginx.conf<br><br>

# Create directory<br>
docker exec my-container mkdir -p /app/logs<br><br>

# Change file permissions<br>
docker exec my-container chmod 755 /app/script.sh<br><br>

# Check file contents<br>
docker exec my-container cat /app/config.json
        </div>

        <h3>docker exec vs docker run</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Aspect</th>
                    <th>docker exec</th>
                    <th>docker run</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Target</strong></td>
                    <td>Existing running container</td>
                    <td>Creates new container</td>
                </tr>
                <tr>
                    <td><strong>Use Case</strong></td>
                    <td>Debug, maintain, interact</td>
                    <td>Start new application</td>
                </tr>
                <tr>
                    <td><strong>Process</strong></td>
                    <td>Additional process in container</td>
                    <td>Main container process</td>
                </tr>
            </tbody>
        </table>

        <div class="success-box">
            <p><strong>Pro Tip:</strong> Use <code>docker exec -it container bash</code> to get a shell inside a running container for interactive debugging and exploration.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 14: Docker Image Commands Overview -->
<div class="slide">
    <div class="content">
        <h2>Docker Image Commands</h2>
        
        <h3>Image Management Commands</h3>
        <div class="highlight-box">
            <p>Docker provides comprehensive commands for managing images: building custom images, listing available images, removing unused images, and transferring images to/from registries.</p>
        </div>

        <h3>Core Image Commands</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>docker build</h4>
                <p>Build images from Dockerfile</p>
            </div>
            <div class="feature-card">
                <h4>docker images</h4>
                <p>List local images</p>
            </div>
            <div class="feature-card">
                <h4>docker pull</h4>
                <p>Download images from registry</p>
            </div>
            <div class="feature-card">
                <h4>docker push</h4>
                <p>Upload images to registry</p>
            </div>
            <div class="feature-card">
                <h4>docker rmi</h4>
                <p>Remove local images</p>
            </div>
            <div class="feature-card">
                <h4>docker tag</h4>
                <p>Tag images with names</p>
            </div>
        </div>

        <h3>Image Workflow</h3>
        <div class="workflow-diagram">
            <div class="workflow-phase">Write Dockerfile</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">docker build</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">docker tag</div>
            <div class="arrow">→</div>
            <div class="workflow-phase">docker push</div>
        </div>

        <h3>Image Lifecycle</h3>
        <ol class="step-list">
            <li><strong>Create Dockerfile:</strong> Define image build instructions</li>
            <li><strong>Build Image:</strong> Use <code>docker build</code> to create image</li>
            <li><strong>Tag Image:</strong> Assign meaningful names and versions</li>
            <li><strong>Test Image:</strong> Run containers to verify functionality</li>
            <li><strong>Push to Registry:</strong> Share image via Docker Hub or private registry</li>
            <li><strong>Pull and Deploy:</strong> Download and run on target systems</li>
        </ol>

        <h3>Image Storage Locations</h3>
        <ul>
            <li><strong>Local Storage:</strong> <code>/var/lib/docker/</code> (Linux) or Docker Desktop storage</li>
            <li><strong>Docker Hub:</strong> Public registry with millions of images</li>
            <li><strong>Private Registries:</strong> AWS ECR, Azure ACR, Google GCR</li>
            <li><strong>Self-hosted:</strong> Docker Registry, Harbor, Nexus</li>
        </ul>

        <div class="success-box">
            <p><strong>Best Practice:</strong> Always tag your images with meaningful names and version numbers for better organization and deployment tracking.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 15: docker build Command -->
<div class="slide">
    <div class="content">
        <h2>docker build Command</h2>
        
        <h3>Building Custom Images</h3>
        <div class="highlight-box">
            <p><strong>docker build</strong> creates Docker images from a Dockerfile and build context. It reads instructions from the Dockerfile and executes them step by step to create a new image.</p>
        </div>

        <h3>Basic Syntax</h3>
        <div class="docker-block">
docker build [OPTIONS] PATH | URL | -<br><br>

# Basic examples:<br>
docker build .                          # Build from current directory<br>
docker build -t myapp:latest .          # Build with tag<br>
docker build -f Dockerfile.prod .       # Use specific Dockerfile<br>
docker build https://github.com/user/repo.git  # Build from Git repo
        </div>

        <h3>Sample Dockerfile</h3>
        <div class="code-block">
# Dockerfile<br>
FROM node:16-alpine<br><br>

# Set working directory<br>
WORKDIR /app<br><br>

# Copy package files<br>
COPY package*.json ./<br><br>

# Install dependencies<br>
RUN npm install<br><br>

# Copy application code<br>
COPY . .<br><br>

# Expose port<br>
EXPOSE 3000<br><br>

# Define startup command<br>
CMD ["npm", "start"]
        </div>

        <h3>docker build Options</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Option</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>-t, --tag</code></td>
                    <td>Name and tag for the image</td>
                    <td><code>docker build -t myapp:v1.0 .</code></td>
                </tr>
                <tr>
                    <td><code>-f, --file</code></td>
                    <td>Specify Dockerfile path</td>
                    <td><code>docker build -f Dockerfile.prod .</code></td>
                </tr>
                <tr>
                    <td><code>--no-cache</code></td>
                    <td>Don't use cache when building</td>
                    <td><code>docker build --no-cache .</code></td>
                </tr>
                <tr>
                    <td><code>--build-arg</code></td>
                    <td>Set build-time variables</td>
                    <td><code>docker build --build-arg VERSION=1.0 .</code></td>
                </tr>
                <tr>
                    <td><code>--target</code></td>
                    <td>Build specific stage in multi-stage</td>
                    <td><code>docker build --target production .</code></td>
                </tr>
                <tr>
                    <td><code>--platform</code></td>
                    <td>Set platform for build</td>
                    <td><code>docker build --platform linux/amd64 .</code></td>
                </tr>
            </tbody>
        </table>

        <h3>Build Process</h3>
        <ol class="step-list">
            <li><strong>Context Creation:</strong> Docker creates build context from specified path</li>
            <li><strong>Dockerfile Parsing:</strong> Docker reads and validates Dockerfile instructions</li>
            <li><strong>Layer Building:</strong> Each instruction creates a new layer</li>
            <li><strong>Cache Utilization:</strong> Docker reuses cached layers when possible</li>
            <li><strong>Image Creation:</strong> Final image is created with all layers</li>
        </ol>

        <h3>Build Examples</h3>
        <div class="code-block">
# Simple build with tag<br>
docker build -t webapp:latest .<br><br>

# Build with build arguments<br>
docker build --build-arg NODE_ENV=production -t webapp:prod .<br><br>

# Build without cache<br>
docker build --no-cache -t webapp:fresh .<br><br>

# Build from specific Dockerfile<br>
docker build -f docker/Dockerfile.dev -t webapp:dev .<br><br>

# Multi-stage build targeting specific stage<br>
docker build --target builder -t webapp:builder .<br><br>

# Build from Git repository<br>
docker build -t webapp https://github.com/username/webapp.git
        </div>

        <h3>Multi-stage Build Example</h3>
        <div class="code-block">
# Multi-stage Dockerfile<br>
FROM node:16 AS builder<br>
WORKDIR /app<br>
COPY package*.json ./<br>
RUN npm install<br>
COPY . .<br>
RUN npm run build<br><br>

FROM nginx:alpine AS production<br>
COPY --from=builder /app/dist /usr/share/nginx/html<br>
EXPOSE 80<br>
CMD ["nginx", "-g", "daemon off;"]
        </div>

        <h3>Build Optimization Tips</h3>
        <ul>
            <li><strong>Layer Caching:</strong> Order instructions from least to most frequently changing</li>
            <li><strong>.dockerignore:</strong> Exclude unnecessary files from build context</li>
            <li><strong>Multi-stage Builds:</strong> Reduce final image size by excluding build tools</li>
            <li><strong>Minimal Base Images:</strong> Use Alpine or distroless images when possible</li>
        </ul>

        <div class="warning-box">
            <p><strong>Security Tip:</strong> Never include secrets like passwords or API keys in Dockerfile. Use build arguments or runtime environment variables instead.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 16: docker images, docker rmi, docker pull, docker push -->
<div class="slide">
    <div class="content">
        <h2>Image Management Commands</h2>
        
        <h3>docker images - Listing Images</h3>
        <div class="code-block">
# List all local images<br>
docker images<br><br>

# List images with specific format<br>
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"<br><br>

# List only image IDs<br>
docker images -q<br><br>

# Show all images including intermediate<br>
docker images -a<br><br>

# Filter images<br>
docker images --filter "dangling=true"<br>
docker images --filter "reference=nginx:*"
        </div>

        <h3>docker pull - Downloading Images</h3>
        <div class="highlight-box">
            <p><strong>docker pull</strong> downloads images from a registry to your local machine. Docker automatically pulls images when running containers if they don't exist locally.</p>
        </div>

        <div class="code-block">
# Pull latest version<br>
docker pull nginx<br><br>

# Pull specific version<br>
docker pull nginx:1.21<br><br>

# Pull from specific registry<br>
docker pull myregistry.com:5000/myapp:latest<br><br>

# Pull all tags of an image<br>
docker pull -a nginx<br><br>

# Pull with platform specification<br>
docker pull --platform linux/amd64 nginx
        </div>

        <h3>docker push - Uploading Images</h3>
        <div class="highlight-box">
            <p><strong>docker push</strong> uploads images from your local machine to a registry. You must be authenticated and have push permissions to the target repository.</p>
        </div>

        <div class="code-block">
# Push to Docker Hub<br>
docker push username/myapp:latest<br><br>

# Push specific tag<br>
docker push username/myapp:v1.0<br><br>

# Push to private registry<br>
docker push myregistry.com:5000/myapp:latest<br><br>

# Push all tags<br>
docker push -a username/myapp
        </div>

        <h3>docker rmi - Removing Images</h3>
        <div class="code-block">
# Remove single image<br>
docker rmi nginx:latest<br><br>

# Remove multiple images<br>
docker rmi nginx:1.20 nginx:1.21<br><br>

# Force remove image<br>
docker rmi -f myapp:latest<br><br>

# Remove all unused images<br>
docker image prune<br><br>

# Remove all images<br>
docker rmi $(docker images -q)<br><br>

# Remove dangling images<br>
docker image prune -f
        </div>

        <h3>docker tag - Tagging Images</h3>
        <div class="code-block">
# Tag existing image<br>
docker tag myapp:latest myapp:v1.0<br><br>

# Tag for Docker Hub<br>
docker tag myapp:latest username/myapp:latest<br><br>

# Tag for private registry<br>
docker tag myapp:latest myregistry.com:5000/myapp:latest<br><br>

# Multiple tags<br>
docker tag myapp:latest myapp:stable<br>
docker tag myapp:latest myapp:production
        </div>

        <h3>Image Information Commands</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Command</th>
                    <th>Purpose</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>docker inspect</code></td>
                    <td>Detailed image information</td>
                    <td><code>docker inspect nginx:latest</code></td>
                </tr>
                <tr>
                    <td><code>docker history</code></td>
                    <td>Show image layer history</td>
                    <td><code>docker history nginx:latest</code></td>
                </tr>
                <tr>
                    <td><code>docker image ls</code></td>
                    <td>Alternative to docker images</td>
                    <td><code>docker image ls</code></td>
                </tr>
                <tr>
                    <td><code>docker image prune</code></td>
                    <td>Remove unused images</td>
                    <td><code>docker image prune -a</code></td>
                </tr>
            </tbody>
        </table>

        <h3>Registry Authentication</h3>
        <div class="code-block">
# Login to Docker Hub<br>
docker login<br><br>

# Login to private registry<br>
docker login myregistry.com:5000<br><br>

# Login with credentials<br>
docker login -u username -p password<br><br>

# Logout<br>
docker logout<br><br>

# View stored credentials<br>
cat ~/.docker/config.json
        </div>

        <div class="success-box">
            <p><strong>Workflow Tip:</strong> Always test your images locally before pushing to a registry. Use meaningful tags and maintain a consistent tagging strategy.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 17: Why We Need Containers -->
<div class="slide">
    <div class="content">
        <h2>Why We Need Containers</h2>
        
        <h3>The Traditional Deployment Problem</h3>
        <div class="highlight-box">
            <p>Before containers, applications faced numerous challenges in deployment and scaling. The "it works on my machine" problem was common, along with dependency conflicts, environment inconsistencies, and resource inefficiencies.</p>
        </div>

        <h3>Traditional Challenges</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Environment Inconsistency</h4>
                <p>Different OS versions, libraries, and configurations between development, testing, and production environments.</p>
            </div>
            <div class="feature-card">
                <h4>Dependency Hell</h4>
                <p>Conflicting library versions, missing dependencies, and complex installation procedures.</p>
            </div>
            <div class="feature-card">
                <h4>Resource Waste</h4>
                <p>Virtual machines consuming excessive resources with full OS overhead for each application.</p>
            </div>
            <div class="feature-card">
                <h4>Slow Deployment</h4>
                <p>Time-consuming setup processes, manual configuration, and lengthy deployment cycles.</p>
            </div>
        </div>

        <h3>How Containers Solve These Problems</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Problem</th>
                    <th>Traditional Solution</th>
                    <th>Container Solution</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Environment Differences</strong></td>
                    <td>Manual configuration management</td>
                    <td>Identical container images everywhere</td>
                </tr>
                <tr>
                    <td><strong>Dependency Conflicts</strong></td>
                    <td>Complex dependency management</td>
                    <td>Isolated container environments</td>
                </tr>
                <tr>
                    <td><strong>Resource Inefficiency</strong></td>
                    <td>One VM per application</td>
                    <td>Multiple containers per host</td>
                </tr>
                <tr>
                    <td><strong>Slow Scaling</strong></td>
                    <td>Provision new VMs</td>
                    <td>Start containers in seconds</td>
                </tr>
                <tr>
                    <td><strong>Complex Deployment</strong></td>
                    <td>Manual installation steps</td>
                    <td>Single container deployment</td>
                </tr>
            </tbody>
        </table>

        <h3>Container Benefits in Detail</h3>
        <ul>
            <li><strong>Portability:</strong> Run anywhere Docker is installed - laptop, server, cloud</li>
            <li><strong>Consistency:</strong> Same environment from development to production</li>
            <li><strong>Efficiency:</strong> Share host OS kernel, minimal resource overhead</li>
            <li><strong>Scalability:</strong> Rapid horizontal scaling with orchestration tools</li>
            <li><strong>Isolation:</strong> Applications don't interfere with each other</li>
            <li><strong>Version Control:</strong> Image versioning enables easy rollbacks</li>
            <li><strong>DevOps Integration:</strong> Perfect fit for CI/CD pipelines</li>
        </ul>

        <h3>Real-World Impact</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Development Speed</h4>
                <p>70% faster development cycles with consistent environments and rapid testing.</p>
            </div>
            <div class="feature-card">
                <h4>Infrastructure Costs</h4>
                <p>60% reduction in infrastructure costs through better resource utilization.</p>
            </div>
            <div class="feature-card">
                <h4>Deployment Frequency</h4>
                <p>10x more frequent deployments with automated container pipelines.</p>
            </div>
            <div class="feature-card">
                <h4>System Reliability</h4>
                <p>50% fewer production issues due to environment consistency.</p>
            </div>
        </div>

        <h3>Container Use Cases</h3>
        <ol>
            <li><strong>Microservices Architecture:</strong> Independent service deployment and scaling</li>
            <li><strong>Cloud Migration:</strong> Lift and shift applications to cloud platforms</li>
            <li><strong>CI/CD Pipelines:</strong> Consistent build and test environments</li>
            <li><strong>Development Environments:</strong> Standardized developer workspaces</li>
            <li><strong>Legacy Application Modernization:</strong> Containerize without rewriting</li>
            <li><strong>Multi-Cloud Deployment:</strong> Portable across different cloud providers</li>
        </ol>

        <div class="success-box">
            <p><strong>Key Insight:</strong> Containers solve the fundamental problem of "it works on my machine" by packaging applications with all their dependencies into portable, consistent units.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 18: Docker Hub Setup -->
<div class="slide">
    <div class="content">
        <h2>Setting Up Docker Hub Account</h2>
        
        <h3>What is Docker Hub?</h3>
        <div class="highlight-box">
            <p><strong>Docker Hub</strong> is Docker's official cloud-based registry service for sharing container images. It provides public and private repositories, automated builds, and integration with development workflows.</p>
        </div>

        <h3>Docker Hub Features</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Public Repositories</h4>
                <p>Free unlimited public repositories for open-source projects</p>
            </div>
            <div class="feature-card">
                <h4>Private Repositories</h4>
                <p>Secure private repositories for proprietary applications</p>
            </div>
            <div class="feature-card">
                <h4>Automated Builds</h4>
                <p>Automatic image builds from GitHub/Bitbucket repositories</p>
            </div>
            <div class="feature-card">
                <h4>Official Images</h4>
                <p>Curated, secure images for popular software</p>
            </div>
        </div>

        <h3>Creating Docker Hub Account</h3>
        <ol class="step-list">
            <li><strong>Visit Docker Hub:</strong> Go to https://hub.docker.com</li>
            <li><strong>Sign Up:</strong> Click "Sign Up" and fill in your details</li>
            <li><strong>Verify Email:</strong> Check your email and verify your account</li>
            <li><strong>Choose Plan:</strong> Select free or paid plan based on needs</li>
            <li><strong>Complete Profile:</strong> Add profile information and avatar</li>
        </ol>

        <h3>Docker Hub Plans</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Plan</th>
                    <th>Price</th>
                    <th>Public Repos</th>
                    <th>Private Repos</th>
                    <th>Features</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Free</strong></td>
                    <td>$0/month</td>
                    <td>Unlimited</td>
                    <td>1</td>
                    <td>Basic features</td>
                </tr>
                <tr>
                    <td><strong>Pro</strong></td>
                    <td>$5/month</td>
                    <td>Unlimited</td>
                    <td>Unlimited</td>
                    <td>Advanced features, support</td>
                </tr>
                <tr>
                    <td><strong>Team</strong></td>
                    <td>$25/month</td>
                    <td>Unlimited</td>
                    <td>Unlimited</td>
                    <td>Team management, SSO</td>
                </tr>
            </tbody>
        </table>

        <h3>Connecting Docker CLI to Docker Hub</h3>
        <div class="code-block">
# Login to Docker Hub<br>
docker login<br><br>

# Enter your Docker Hub credentials when prompted<br>
Username: your-username<br>
Password: your-password<br><br>

# Verify login<br>
docker info | grep Username<br><br>

# Alternative login with credentials<br>
docker login -u your-username -p your-password
        </div>

        <h3>Repository Naming Convention</h3>
        <div class="docker-block">
# Docker Hub repository format:<br>
username/repository-name:tag<br><br>

# Examples:<br>
rashirana/my-web-app:latest<br>
rashirana/my-web-app:v1.0<br>
rashirana/my-web-app:development<br><br>

# Official images (no username):<br>
nginx:latest<br>
ubuntu:20.04<br>
node:16-alpine
        </div>

        <h3>Creating Your First Repository</h3>
        <ol class="step-list">
            <li><strong>Login to Docker Hub:</strong> Access your Docker Hub dashboard</li>
            <li><strong>Create Repository:</strong> Click "Create Repository" button</li>
            <li><strong>Repository Details:</strong> Enter name, description, and visibility</li>
            <li><strong>Configure Settings:</strong> Set up automated builds if needed</li>
            <li><strong>Save Repository:</strong> Complete the repository creation</li>
        </ol>

        <div class="warning-box">
            <p><strong>Security Note:</strong> Never store sensitive information like passwords or API keys in public Docker images. Use environment variables or secrets management instead.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 19: Pulling and Pushing to Docker Hub -->
<div class="slide">
    <div class="content">
        <h2>Pulling and Pushing to Docker Hub</h2>
        
        <h3>Pulling Images from Docker Hub</h3>
        <div class="highlight-box">
            <p>Docker Hub hosts millions of container images. You can pull official images, community images, or images from specific users to use as base images or run directly.</p>
        </div>

        <h3>Common Pull Operations</h3>
        <div class="code-block">
# Pull official images<br>
docker pull nginx                    # Latest nginx<br>
docker pull ubuntu:20.04            # Specific Ubuntu version<br>
docker pull node:16-alpine          # Node.js on Alpine Linux<br>
docker pull mysql:8.0               # MySQL database<br><br>

# Pull user images<br>
docker pull username/myapp:latest   # User's application<br>
docker pull username/myapp:v1.0     # Specific version<br><br>

# Pull from organizations<br>
docker pull bitnami/nginx           # Bitnami's nginx image<br>
docker pull microsoft/dotnet        # Microsoft's .NET image
        </div>

        <h3>Exploring Docker Hub</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Official Images</h4>
                <p>Curated by Docker, regularly updated, security-scanned images for popular software</p>
            </div>
            <div class="feature-card">
                <h4>Verified Publishers</h4>
                <p>Images from verified software vendors and organizations</p>
            </div>
            <div class="feature-card">
                <h4>Community Images</h4>
                <p>User-contributed images for various applications and use cases</p>
            </div>
            <div class="feature-card">
                <h4>Automated Builds</h4>
                <p>Images automatically built from source code repositories</p>
            </div>
        </div>

        <h3>Pushing Images to Docker Hub</h3>
        <div class="highlight-box">
            <p>To push images to Docker Hub, you must tag them with your Docker Hub username and ensure you're authenticated. The image will be uploaded to your repository.</p>
        </div>

        <h3>Push Workflow</h3>
        <div class="code-block">
# 1. Build your image<br>
docker build -t my-web-app .<br><br>

# 2. Tag for Docker Hub<br>
docker tag my-web-app username/my-web-app:latest<br>
docker tag my-web-app username/my-web-app:v1.0<br><br>

# 3. Login to Docker Hub<br>
docker login<br><br>

# 4. Push to Docker Hub<br>
docker push username/my-web-app:latest<br>
docker push username/my-web-app:v1.0<br><br>

# 5. Verify on Docker Hub website<br>
# Visit: https://hub.docker.com/r/username/my-web-app
        </div>

        <h3>Tagging Strategies</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Tag Type</th>
                    <th>Example</th>
                    <th>Use Case</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Latest</strong></td>
                    <td><code>myapp:latest</code></td>
                    <td>Most recent stable version</td>
                </tr>
                <tr>
                    <td><strong>Semantic Version</strong></td>
                    <td><code>myapp:v1.2.3</code></td>
                    <td>Specific release versions</td>
                </tr>
                <tr>
                    <td><strong>Environment</strong></td>
                    <td><code>myapp:dev</code>, <code>myapp:prod</code></td>
                    <td>Environment-specific builds</td>
                </tr>
                <tr>
                    <td><strong>Git Commit</strong></td>
                    <td><code>myapp:abc123</code></td>
                    <td>Specific code commits</td>
                </tr>
                <tr>
                    <td><strong>Date-based</strong></td>
                    <td><code>myapp:2024-01-15</code></td>
                    <td>Time-based releases</td>
                </tr>
            </tbody>
        </table>

        <h3>Managing Repository Settings</h3>
        <div class="code-block">
# View repository information<br>
docker search username/myapp<br><br>

# Pull specific tags<br>
docker pull username/myapp:v1.0<br>
docker pull username/myapp:latest<br><br>

# List all tags for an image<br>
# Visit Docker Hub web interface or use API<br>
curl -s https://registry.hub.docker.com/v2/repositories/username/myapp/tags/
        </div>

        <h3>Automated Builds</h3>
        <ol class="step-list">
            <li><strong>Connect Repository:</strong> Link GitHub/Bitbucket repository to Docker Hub</li>
            <li><strong>Configure Build Rules:</strong> Set up build triggers and tag rules</li>
            <li><strong>Dockerfile Location:</strong> Specify Dockerfile path in repository</li>
            <li><strong>Build Settings:</strong> Configure build environment and variables</li>
            <li><strong>Trigger Builds:</strong> Automatic builds on code commits</li>
        </ol>

        <h3>Best Practices</h3>
        <ul>
            <li><strong>Meaningful Tags:</strong> Use descriptive tags that indicate version or purpose</li>
            <li><strong>Security Scanning:</strong> Enable vulnerability scanning for your images</li>
            <li><strong>Documentation:</strong> Provide clear README and usage instructions</li>
            <li><strong>Size Optimization:</strong> Keep images small using multi-stage builds</li>
            <li><strong>Regular Updates:</strong> Keep base images and dependencies updated</li>
        </ul>

        <div class="success-box">
            <p><strong>Pro Tip:</strong> Always test your images locally before pushing to Docker Hub. Use semantic versioning for better version management.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 20: Lab Setup - EC2 Ubuntu Machine -->
<div class="slide">
    <div class="content">
        <h2>Lab: Build Docker Image and Run Container</h2>
        
        <h3>Lab Environment Setup</h3>
        <div class="highlight-box">
            <p>We'll create a complete hands-on lab using an EC2 Ubuntu instance to build a custom Docker image and run containers. This lab covers the entire Docker workflow from installation to deployment.</p>
        </div>

        <h3>Prerequisites</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>AWS Account</h4>
                <p>Access to AWS console to launch EC2 instances</p>
            </div>
            <div class="feature-card">
                <h4>SSH Key Pair</h4>
                <p>EC2 key pair for secure instance access</p>
            </div>
            <div class="feature-card">
                <h4>Docker Hub Account</h4>
                <p>Free Docker Hub account for image registry</p>
            </div>
            <div class="feature-card">
                <h4>Basic Linux Knowledge</h4>
                <p>Familiarity with Linux commands and text editors</p>
            </div>
        </div>

        <h3>EC2 Instance Setup</h3>
        <div class="lab-section">
            <h4>Launch EC2 Instance</h4>
            <ol class="step-list">
                <li><strong>AWS Console:</strong> Navigate to EC2 service in AWS console</li>
                <li><strong>Launch Instance:</strong> Click "Launch Instance" button</li>
                <li><strong>Choose AMI:</strong> Select Ubuntu Server 22.04 LTS (Free tier eligible)</li>
                <li><strong>Instance Type:</strong> Choose t2.micro (Free tier eligible)</li>
                <li><strong>Key Pair:</strong> Select existing key pair or create new one</li>
                <li><strong>Security Group:</strong> Allow SSH (port 22) and HTTP (port 80)</li>
                <li><strong>Launch:</strong> Review and launch the instance</li>
            </ol>
        </div>

        <h3>Security Group Configuration</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Type</th>
                    <th>Protocol</th>
                    <th>Port Range</th>
                    <th>Source</th>
                    <th>Purpose</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>SSH</td>
                    <td>TCP</td>
                    <td>22</td>
                    <td>Your IP/0.0.0.0/0</td>
                    <td>Remote access</td>
                </tr>
                <tr>
                    <td>HTTP</td>
                    <td>TCP</td>
                    <td>80</td>
                    <td>0.0.0.0/0</td>
                    <td>Web application</td>
                </tr>
                <tr>
                    <td>Custom TCP</td>
                    <td>TCP</td>
                    <td>8080</td>
                    <td>0.0.0.0/0</td>
                    <td>Alternative web port</td>
                </tr>
                <tr>
                    <td>Custom TCP</td>
                    <td>TCP</td>
                    <td>3000</td>
                    <td>0.0.0.0/0</td>
                    <td>Node.js application</td>
                </tr>
            </tbody>
        </table>

        <h3>Connect to EC2 Instance</h3>
        <div class="code-block">
# Connect via SSH (replace with your details)<br>
ssh -i "your-key.pem" ubuntu@ec2-xx-xx-xx-xx.compute-1.amazonaws.com<br><br>

# Update system packages<br>
sudo apt update && sudo apt upgrade -y<br><br>

# Install required packages<br>
sudo apt install -y curl wget git vim
        </div>

        <h3>Lab Project Overview</h3>
        <p>We'll build a simple Node.js web application, containerize it with Docker, and deploy it to our EC2 instance. The application will:</p>
        <ul>
            <li>Display a welcome message with system information</li>
            <li>Show current date and time</li>
            <li>Demonstrate Docker environment variables</li>
            <li>Include health check endpoint</li>
        </ul>

        <div class="success-box">
            <p><strong>Lab Goal:</strong> By the end of this lab, you'll have a complete understanding of the Docker workflow: build, tag, push, pull, and run containers.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 21: Lab Implementation -->
<div class="slide">
    <div class="content">
        <h2>Lab: Docker Implementation</h2>
        
        <div class="lab-section">
            <h3>Step 1: Install Docker on Ubuntu</h3>
            <div class="code-block">
# Install Docker<br>
curl -fsSL https://get.docker.com -o get-docker.sh<br>
sudo sh get-docker.sh<br><br>

# Add user to docker group<br>
sudo usermod -aG docker ubuntu<br><br>

# Logout and login again, or run:<br>
newgrp docker<br><br>

# Verify installation<br>
docker --version<br>
docker run hello-world
            </div>

            <h3>Step 2: Create Application Files</h3>
            <div class="code-block">
# Create project directory<br>
mkdir docker-lab && cd docker-lab<br><br>

# Create package.json<br>
cat > package.json << 'EOF'<br>
{<br>
&nbsp;&nbsp;"name": "docker-lab-app",<br>
&nbsp;&nbsp;"version": "1.0.0",<br>
&nbsp;&nbsp;"description": "Docker Lab Web Application",<br>
&nbsp;&nbsp;"main": "app.js",<br>
&nbsp;&nbsp;"scripts": {<br>
&nbsp;&nbsp;&nbsp;&nbsp;"start": "node app.js"<br>
&nbsp;&nbsp;},<br>
&nbsp;&nbsp;"dependencies": {<br>
&nbsp;&nbsp;&nbsp;&nbsp;"express": "^4.18.0"<br>
&nbsp;&nbsp;}<br>
}<br>
EOF
            </div>

            <h3>Step 3: Create Node.js Application</h3>
            <div class="code-block">
# Create app.js<br>
cat > app.js << 'EOF'<br>
const express = require('express');<br>
const os = require('os');<br>
const app = express();<br>
const PORT = process.env.PORT || 3000;<br><br>

app.get('/', (req, res) => {<br>
&nbsp;&nbsp;const response = {<br>
&nbsp;&nbsp;&nbsp;&nbsp;message: 'Hello from Docker Lab!',<br>
&nbsp;&nbsp;&nbsp;&nbsp;hostname: os.hostname(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;platform: os.platform(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;uptime: os.uptime(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;timestamp: new Date().toISOString(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;environment: process.env.NODE_ENV || 'development'<br>
&nbsp;&nbsp;};<br>
&nbsp;&nbsp;res.json(response);<br>
});<br><br>

app.get('/health', (req, res) => {<br>
&nbsp;&nbsp;res.status(200).json({ status: 'healthy' });<br>
});<br><br>

app.listen(PORT, () => {<br>
&nbsp;&nbsp;console.log(`Server running on port ${PORT}`);<br>
});<br>
EOF
            </div>

            <h3>Step 4: Create Dockerfile</h3>
            <div class="code-block">
# Create Dockerfile<br>
cat > Dockerfile << 'EOF'<br>
# Use official Node.js runtime as base image<br>
FROM node:16-alpine<br><br>

# Set working directory in container<br>
WORKDIR /app<br><br>

# Copy package.json and package-lock.json<br>
COPY package*.json ./<br><br>

# Install dependencies<br>
RUN npm install --only=production<br><br>

# Copy application code<br>
COPY . .<br><br>

# Create non-root user<br>
RUN addgroup -g 1001 -S nodejs<br>
RUN adduser -S nextjs -u 1001<br>
USER nextjs<br><br>

# Expose port<br>
EXPOSE 3000<br><br>

# Health check<br>
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \<br>
&nbsp;&nbsp;CMD curl -f http://localhost:3000/health || exit 1<br><br>

# Start application<br>
CMD ["npm", "start"]<br>
EOF
            </div>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 22: Lab Execution and Testing -->
<div class="slide">
    <div class="content">
        <h2>Lab: Build, Run, and Deploy</h2>
        
        <div class="lab-section">
            <h3>Step 5: Build Docker Image</h3>
            <div class="code-block">
# Build the Docker image<br>
docker build -t docker-lab-app:latest .<br><br>

# Verify image was created<br>
docker images<br><br>

# Inspect the image<br>
docker inspect docker-lab-app:latest<br><br>

# Check image history<br>
docker history docker-lab-app:latest
            </div>

            <h3>Step 6: Run Container Locally</h3>
            <div class="code-block">
# Run container in background<br>
docker run -d -p 3000:3000 --name my-app docker-lab-app:latest<br><br>

# Check running containers<br>
docker ps<br><br>

# Test the application<br>
curl http://localhost:3000<br>
curl http://localhost:3000/health<br><br>

# View container logs<br>
docker logs my-app<br><br>

# Execute commands in container<br>
docker exec -it my-app sh
            </div>

            <h3>Step 7: Tag and Push to Docker Hub</h3>
            <div class="code-block">
# Login to Docker Hub<br>
docker login<br><br>

# Tag image for Docker Hub (replace 'username' with your Docker Hub username)<br>
docker tag docker-lab-app:latest username/docker-lab-app:latest<br>
docker tag docker-lab-app:latest username/docker-lab-app:v1.0<br><br>

# Push to Docker Hub<br>
docker push username/docker-lab-app:latest<br>
docker push username/docker-lab-app:v1.0<br><br>

# Verify on Docker Hub website<br>
echo "Visit: https://hub.docker.com/r/username/docker-lab-app"
            </div>

            <h3>Step 8: Test Pull and Run from Registry</h3>
            <div class="code-block">
# Stop and remove local container<br>
docker stop my-app<br>
docker rm my-app<br><br>

# Remove local image<br>
docker rmi docker-lab-app:latest<br><br>

# Pull from Docker Hub and run<br>
docker run -d -p 8080:3000 --name production-app username/docker-lab-app:latest<br><br>

# Test the deployed application<br>
curl http://localhost:8080<br><br>

# Check public access (replace with your EC2 public IP)<br>
curl http://your-ec2-public-ip:8080
            </div>

            <h3>Step 9: Container Management</h3>
            <div class="code-block">
# Monitor container resources<br>
docker stats production-app<br><br>

# View detailed container information<br>
docker inspect production-app<br><br>

# Update container with environment variables<br>
docker stop production-app<br>
docker rm production-app<br>
docker run -d -p 8080:3000 -e NODE_ENV=production --name production-app username/docker-lab-app:latest<br><br>

# Test environment variable<br>
curl http://localhost:8080
            </div>
        </div>

        <h3>Lab Verification Checklist</h3>
        <ul>
            <li>✅ Docker installed and running on EC2 Ubuntu instance</li>
            <li>✅ Node.js application created with health check endpoint</li>
            <li>✅ Dockerfile created with best practices (non-root user, health check)</li>
            <li>✅ Docker image built successfully</li>
            <li>✅ Container runs locally and responds to HTTP requests</li>
            <li>✅ Image tagged and pushed to Docker Hub</li>
            <li>✅ Image pulled from registry and deployed</li>
            <li>✅ Application accessible from public internet</li>
        </ul>

        <div class="success-box">
            <p><strong>Congratulations!</strong> You've successfully completed the Docker lab, demonstrating the complete container lifecycle from development to deployment.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

<!-- Slide 23: Summary and Best Practices -->
<div class="slide">
    <div class="content">
        <h2>Summary and Best Practices</h2>
        
        <h3>Key Concepts Covered</h3>
        <div class="highlight-box">
            <ul>
                <li>Container fundamentals and benefits over traditional deployment</li>
                <li>Docker architecture: Engine, Images, Containers, and Registry</li>
                <li>Essential Docker commands for container and image management</li>
                <li>Docker Hub setup and image registry operations</li>
                <li>Hands-on experience building and deploying containerized applications</li>
                <li>Complete Docker workflow from development to production</li>
            </ul>
        </div>

        <h3>Docker Best Practices</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Image Optimization</h4>
                <p>Use multi-stage builds, minimal base images, and .dockerignore files</p>
            </div>
            <div class="feature-card">
                <h4>Security</h4>
                <p>Run as non-root user, scan for vulnerabilities, avoid secrets in images</p>
            </div>
            <div class="feature-card">
                <h4>Tagging Strategy</h4>
                <p>Use semantic versioning, meaningful tags, and consistent naming</p>
            </div>
            <div class="feature-card">
                <h4>Resource Management</h4>
                <p>Set resource limits, use health checks, and monitor container metrics</p>
            </div>
        </div>

        <h3>Production Considerations</h3>
        <ul>
            <li><strong>Orchestration:</strong> Use Kubernetes, Docker Swarm, or cloud container services</li>
            <li><strong>Monitoring:</strong> Implement logging, metrics, and alerting for containers</li>
            <li><strong>Networking:</strong> Design proper network architecture for container communication</li>
            <li><strong>Storage:</strong> Use persistent volumes for stateful applications</li>
            <li><strong>CI/CD Integration:</strong> Automate build, test, and deployment pipelines</li>
            <li><strong>Security Scanning:</strong> Regular vulnerability assessments and compliance checks</li>
        </ul>

        <h3>Next Steps</h3>
        <ol>
            <li><strong>Container Orchestration:</strong> Learn Kubernetes for production container management</li>
            <li><strong>Docker Compose:</strong> Multi-container application orchestration</li>
            <li><strong>Advanced Networking:</strong> Custom networks, service discovery, load balancing</li>
            <li><strong>Persistent Storage:</strong> Volumes, bind mounts, and storage drivers</li>
            <li><strong>Security Hardening:</strong> Container security best practices and tools</li>
            <li><strong>Cloud Integration:</strong> AWS ECS, Azure Container Instances, Google Cloud Run</li>
        </ol>

        <h3>Troubleshooting Tips</h3>
        <div class="feature-grid">
            <div class="feature-card">
                <h4>Container Issues</h4>
                <p>Check logs with <code>docker logs</code>, inspect with <code>docker inspect</code></p>
            </div>
            <div class="feature-card">
                <h4>Image Problems</h4>
                <p>Verify Dockerfile syntax, check build context, review layer history</p>
            </div>
            <div class="feature-card">
                <h4>Network Connectivity</h4>
                <p>Verify port mappings, check firewall rules, test with <code>docker exec</code></p>
            </div>
            <div class="feature-card">
                <h4>Performance Issues</h4>
                <p>Monitor with <code>docker stats</code>, optimize images, set resource limits</p>
            </div>
        </div>

        <h3>Additional Resources</h3>
        <ul>
            <li>Docker Official Documentation: https://docs.docker.com/</li>
            <li>Docker Hub: https://hub.docker.com/</li>
            <li>Docker Best Practices: https://docs.docker.com/develop/best-practices/</li>
            <li>Dockerfile Reference: https://docs.docker.com/engine/reference/builder/</li>
        </ul>

        <div class="success-box">
            <p><strong>Remember:</strong> Containerization is not just about technology—it's about creating consistent, portable, and scalable applications that enable modern DevOps practices.</p>
        </div>
    </div>
    <div class="slide-footer">Prepared By: Rashi Rana<br>Corporate Trainer</div>
</div>

</body>
</html>
